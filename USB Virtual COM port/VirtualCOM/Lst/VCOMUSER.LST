ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 1   


ARM COMPILER V2.53, COMPILATION OF MODULE VCOMuser
OBJECT MODULE PLACED IN .\Obj\VCOMuser.obj
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe VCOMuser.c THUMB DEFINE(MCB2140) DEBUG PRINT(.\LST\VCOMUSER.LST) TABS(4) OBJ
                    -ECT(.\Obj\VCOMuser.obj) 

stmt  level    source

    1          
    2          #include <string.h>
    3          #include <LPC214x.h>                        /* LPC214x definitions */
    4          
    5          #include "type.h"
    6          #include "usb.h"
    7          #include "usbhw.h"
    8          #include "usbcfg.h"
    9          #include "usbcore.h"
   10          #include "vcomuser.h"
   11          #include "demo.h"
   12          
   13          #define CR     0x0D
   14          
   15          static BYTE KeyPressed = 0;
   16          
   17          BYTE ReportStatus0 = 0, ReportStatus1 = 0;
   18          BYTE Data2Host0 = 0, Data2Host1 = 0;
   19          
   20          #if USB_VCOM
   21          BYTE RxLength0, RxLength1;
   22          
   23          BYTE  USB2UARTBuf0[USB_MAX_PACKET0];
   24          BYTE  USB2UARTBuf1[USB_MAX_PACKET0];
   25          
   26          BYTE  UART2USBBuf0[USB_MAX_PACKET0];
   27          BYTE  UART2USBBuf1[USB_MAX_PACKET0];
   28          
   29          /* if the portNum is 0, EP1 is the endpoints for 
   30          STATUS IN, EP2 EP is BULK IN, BULK OUT and UART0 Virtual COM port.
   31             if the portNum is 1, EP4 is the endpoints for 
   32          STATUS IN, EP5 is BULK IN, BULK OUT and UART1 Virtual COM port */
   33          
   34          void DeviceData2UART( BYTE portNum )
   35          {
   36   1       DWORD cnt, i;
   37   1       BYTE *pData;
   38   1       BYTE status=0;
   39   1      
   40   1        if ( portNum == 0 )                   //if Data is being send from COMx
   41   1        {
   42   2          pData = &USB2UARTBuf0[0];
   43   2          cnt = USB_ReadEP(0x02, pData);
   44   2          switch(*pData)
   45   2          {
   46   3           case '1': 
   47   3           {
   48   4              if(IOPIN1 & 0x00010000)
   49   4                  {IOCLR1 = 0x00010000;}
   50   4              else
   51   4                  {IOSET1 = 0x00010000;}
   52   4              break;
   53   4           }
   54   3           case '2': 
   55   3           {
   56   4              if(IOPIN1 & 0x00020000)
   57   4                  {IOCLR1 = 0x00020000;}
   58   4              else
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 2   

   59   4                  {IOSET1 = 0x00020000;}
   60   4              break;
   61   4           }
   62   3           case '3': 
   63   3           {
   64   4              if(IOPIN1 & 0x00040000)
   65   4                  {IOCLR1 = 0x00040000;}
   66   4              else
   67   4                  {IOSET1 = 0x00040000;}
   68   4              break;
   69   4           }
   70   3           case '4': 
   71   3           {
   72   4              if(IOPIN1 & 0x00080000)                                                                          
   73   4                  {IOCLR1 = 0x00080000;}
   74   4              else
   75   4                  {IOSET1 = 0x00080000;}
   76   4              break;
   77   4           }
   78   3           
   79   3           default:
   80   3           break;  
   81   3           
   82   3          }
   83   2        }
   84   1        else if ( portNum == 1 )               //if Data is being send from COMx+1
   85   1        {
   86   2          pData = &USB2UARTBuf1[0];
   87   2          cnt = USB_ReadEP(0x05, pData);
   88   2        }
   89   1        return;
   90   1      }
*** WARNING C47 IN LINE 36 OF VCOMUSER.C: 'i': unreferenced local variable
   91          
   92          void DeviceData2Host( BYTE portNum )
   93          {
   94   1       const BYTE msg1[] = "SW1 pressed\r\n";
   95   1       const BYTE msg2[] = "SW2 pressed\r\n";
   96   1       const BYTE msg3[] = "SW3 pressed\r\n";
   97   1       const BYTE msg4[] = "SW4 pressed\r\n";
   98   1       BYTE length;
   99   1       
  100   1       
  101   1        if (!SW1 && !KeyPressed)              /* Check if S2 is pressed */
  102   1        {
  103   2         KeyPressed = 1;
  104   2         length = strlen(msg1);
  105   2         memcpy( UART2USBBuf0, msg1, length );
  106   2         USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
  107   2         KeyPressed = 0;
  108   2        }
  109   1        if (!SW2 && !KeyPressed)              /* Check if S2 is pressed */
  110   1        {
  111   2         KeyPressed = 1;
  112   2         length = strlen(msg2);
  113   2         memcpy( UART2USBBuf0, msg2, length );
  114   2         USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
  115   2         KeyPressed = 0;
  116   2        }
  117   1        if (!SW3 && !KeyPressed)              /* Check if S2 is pressed */
  118   1        {
  119   2         KeyPressed = 1;
  120   2         length = strlen(msg3);
  121   2         memcpy( UART2USBBuf0, msg3, length );
  122   2         USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
  123   2         KeyPressed = 0;
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 3   

  124   2        }
  125   1        if (!SW4 && !KeyPressed)              /* Check if S2 is pressed */
  126   1        {
  127   2         KeyPressed = 1;
  128   2         length = strlen(msg4);
  129   2         memcpy( UART2USBBuf0, msg4, length );
  130   2         USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
  131   2         KeyPressed = 0;
  132   2        }
  133   1      
  134   1       
  135   1       return;
  136   1      }
*** WARNING C47 IN LINE 92 OF VCOMUSER.C: 'portNum': unreferenced parameter
  137          #endif
  138          
  139          /*
  140           *  USB Power Event Callback
  141           *    Parameter:       power: On(TRUE)/Off(FALSE)
  142           */
  143          
  144          #if USB_POWER_EVENT
               void USB_Power_Event (BOOL  power) {
                 power;
               }
               #endif
  149          
  150          
  151          /*
  152           *  USB Reset Event Callback
  153           */
  154          
  155          #if USB_RESET_EVENT
  156          void USB_Reset_Event (void) {
  157   1        USB_ResetCore();
  158   1      }
  159          #endif
  160          
  161          
  162          /*
  163           *  USB Suspend Event Callback
  164           */
  165          
  166          #if USB_SUSPEND_EVENT
               void USB_Suspend_Event (void) {
               }
               #endif
  170          
  171          
  172          /*
  173           *  USB Resume Event Callback
  174           */
  175          
  176          #if USB_RESUME_EVENT
               void USB_Resume_Event (void) {
               }
               #endif
  180          
  181          
  182          /*
  183           *  USB Remote Wakeup Event Callback
  184           */
  185          
  186          #if USB_WAKEUP_EVENT
               void USB_WakeUp_Event (void) {
               }
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 4   

               #endif
  190          
  191          
  192          /*
  193           *  USB Start of frame Event Callback
  194           *    Parameter:       frame: 11-bit Frame Number
  195           */
  196          
  197          #if USB_SOF_EVENT
               void USB_SOF_Event (DWORD frame) {
                 frame;
               }
               #endif
  202          
  203          
  204          /*
  205           *  USB Error Event Callback
  206           *    Parameter:       error: Error Code
  207           */
  208          
  209          #if USB_ERROR_EVENT
               void USB_Error_Event (DWORD error) {
                 error;
               }
               #endif
  214          
  215          /*
  216           *  USB Set Configuration Event Callback
  217           */
  218          #if USB_CONFIGURE_EVENT
  219          void USB_Configure_Event (void) {
  220   1        if (USB_Configuration) {             /* Check if USB is configured */
  221   2          ReportStatus0 = ReportStatus1 = 1;
  222   2          Data2Host0 = Data2Host1 = 1;
  223   2        }
  224   1      }
  225          #endif
  226          
  227          /*
  228           *  USB Set Interface Event Callback
  229           */
  230          
  231          #if USB_INTERFACE_EVENT
               void USB_Interface_Event (void) {
               }
               #endif
  235          
  236          /*
  237           *  USB Set/Clear Feature Event Callback
  238           */
  239          
  240          #if USB_FEATURE_EVENT
               void USB_Feature_Event (void) {
               }
               #endif
  244          
  245          
  246          #define P_EP(n) ((USB_EP_EVENT & (1 << (n))) ? USB_EndPoint##n : NULL)
  247          
  248          /* USB Endpoint Events Callback Pointers */
  249          const void (* USB_P_EP[16]) (DWORD event) = {
  250            P_EP(0),
  251            P_EP(1),
  252            P_EP(2),
  253            P_EP(3),
  254            P_EP(4),
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 5   

  255            P_EP(5),
  256            P_EP(6),
  257            P_EP(7),
  258            P_EP(8),
  259            P_EP(9),
  260            P_EP(10),
  261            P_EP(11),
  262            P_EP(12),
  263            P_EP(13),
  264            P_EP(14),
  265            P_EP(15),
  266          };
  267          
  268          /*
  269           *  USB Endpoint 1 Event Callback
  270           *    Parameter:       event
  271           */
  272          
  273          void USB_EndPoint1 (DWORD event) {
  274   1        event;
  275   1      }
  276          
  277          /*
  278           *  USB Endpoint 2 Event Callback
  279           *    Parameter:       event
  280           */
  281          
  282          void USB_EndPoint2 (DWORD event) {
  283   1        switch (event) {
  284   2          case USB_EVT_IN:
  285   2            Data2Host0 = 1;
  286   2            break;
  287   2          case USB_EVT_OUT:
  288   2            DeviceData2UART( 0 );
  289   2            break;
  290   2        }
  291   1        event;
  292   1      }
  293          
  294          
  295          /*
  296           *  USB Endpoint 3 Event Callback
  297           *    Parameter:       event
  298           */
  299          
  300          void USB_EndPoint3 (DWORD event) {
  301   1        event;
  302   1      }
  303          
  304          /*
  305           *  USB Endpoint 4 Event Callback
  306           *    Parameter:       event
  307           */
  308          
  309          void USB_EndPoint4 (DWORD event) {
  310   1        event;
  311   1      }
  312          
  313          /*
  314           *  USB Endpoint 5 Event Callback
  315           *    Parameter:       event
  316           */
  317          
  318          void USB_EndPoint5 (DWORD event) {
  319   1        switch (event) {
  320   2          case USB_EVT_IN:
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 6   

  321   2            Data2Host1 = 1;
  322   2            break;
  323   2          case USB_EVT_OUT:
  324   2            DeviceData2UART( 1 );
  325   2            break;
  326   2        }
  327   1        event;
  328   1      }
  329          
  330          /*
  331           *  USB Endpoint 6 Event Callback
  332           *    Parameter:       event
  333           */
  334          
  335          void USB_EndPoint6 (DWORD event) {
  336   1        event;
  337   1      }
  338          
  339          
  340          /*
  341           *  USB Endpoint 7 Event Callback
  342           *    Parameter:       event
  343           */
  344          
  345          void USB_EndPoint7 (DWORD event) {
  346   1        event;
  347   1      }
  348          
  349          
  350          /*
  351           *  USB Endpoint 8 Event Callback
  352           *    Parameter:       event
  353           */
  354          
  355          void USB_EndPoint8 (DWORD event) {
  356   1        event;
  357   1      }
  358          
  359          
  360          /*
  361           *  USB Endpoint 9 Event Callback
  362           *    Parameter:       event
  363           */
  364          
  365          void USB_EndPoint9 (DWORD event) {
  366   1        event;
  367   1      }
  368          
  369          
  370          /*
  371           *  USB Endpoint 10 Event Callback
  372           *    Parameter:       event
  373           */
  374          
  375          void USB_EndPoint10 (DWORD event) {
  376   1        event;
  377   1      }
  378          
  379          
  380          /*
  381           *  USB Endpoint 11 Event Callback
  382           *    Parameter:       event
  383           */
  384          
  385          void USB_EndPoint11 (DWORD event) {
  386   1        event;
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 7   

  387   1      }
  388          
  389          /*
  390           *  USB Endpoint 12 Event Callback
  391           *    Parameter:       event
  392           */
  393          
  394          void USB_EndPoint12 (DWORD event) {
  395   1        event;
  396   1      }
  397          
  398          
  399          /*
  400           *  USB Endpoint 13 Event Callback
  401           *    Parameter:       event
  402           */
  403          
  404          void USB_EndPoint13 (DWORD event) {
  405   1        event;
  406   1      }
  407          
  408          
  409          /*
  410           *  USB Endpoint 14 Event Callback
  411           *    Parameter:       event
  412           */
  413          
  414          void USB_EndPoint14 (DWORD event) {
  415   1        event;
  416   1      }
  417          
  418          
  419          /*
  420           *  USB Endpoint 15 Event Callback
  421           *    Parameter:       event
  422           */
  423          
  424          void USB_EndPoint15 (DWORD event) {
  425   1        event;
  426   1      }
  427          
  428          
  429          
  430          /* UART setup and simple putc() and getc() routine */
  431          /* Default setting of CCLK is 60Mhz, VPBCLK is 1/4 = 15Mhz */
  432          
  433          void init_serial (void)  {     /* Initialize Serial Interface       */
  434   1      
  435   1      #if NO_UART_CABLE
               #else
  437   1        PINSEL0 = 0x00050005;        /* Enable RxD1 and TxD1, RxD0 and TxD0 */
  438   1      #endif
  439   1        
  440   1        U0LCR = 0x83;                /* 8 bits, no Parity, 1 Stop bit     */
  441   1        U0DLL = 97;                  /* 9600 Baud Rate @ 15MHz VPB Clock  */
  442   1        U0LCR = 0x03;                /* DLAB = 0                          */  
  443   1        U0FCR = 0x07;                /* Enable and reset TX and RX FIFO. */
  444   1      
  445   1        U1LCR = 0x83;                /* 8 bits, no Parity, 1 Stop bit     */
  446   1        U1DLL = 97;                  /* 9600 Baud Rate @ 15MHz VPB Clock  */
  447   1        U1LCR = 0x03;                /* DLAB = 0                          */
  448   1        U1FCR = 0x07;                /* Enable and reset TX and RX FIFO. */
  449   1      }
  450          
  451          int putchar(BYTE portNum, int ch)  {     /* Write character to Serial Port    */
  452   1      
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 8   

  453   1        if ( portNum == 0 ) {
  454   2          if (ch == '\n')  {
  455   3              while (!(U0LSR & 0x20));
  456   3              U0THR = CR;                          /* output CR */
  457   3          }
  458   2          while (!(U0LSR & 0x20));
  459   2          return (U0THR = ch);
  460   2        }
  461   1        else {
  462   2          if (ch == '\n')  {
  463   3              while (!(U1LSR & 0x20));
  464   3              U1THR = CR;                          /* output CR */
  465   3          }
  466   2          while (!(U1LSR & 0x20));
  467   2          return (U1THR = ch);
  468   2        }
  469   1      }
  470          
  471          int getchar ( BYTE portNum )  {                    /* Read character from Serial Port   */
  472   1      
  473   1        if ( portNum == 0 ) {
  474   2          while (!(U0LSR & 0x01));
  475   2          return (U0RBR);
  476   2        }
  477   1        else {
  478   2          while (!(U1LSR & 0x01));
  479   2          return (U1RBR);
  480   2        }
  481   1      }
  482          
  483          /*  Setup SIO configuration based on the channel number */
  484          void SetSIOBaudrate( BYTE channelNum, BYTE Data )
  485          {
  486   1          /* Data = 0x1       Baudrate = 115,200
  487   1             Data = 0x2       Baudrate = 57,600
  488   1             Data = 0x3       Baudrate = 38,400
  489   1             Data = 0x6       Baudrate = 19,200
  490   1             Data = 0x0C      Baudrate = 9,600 */
  491   1        
  492   1        /* PCLK is set the same as CCLK at 60Mhz */ 
  493   1        if ( channelNum == 0 ) {
  494   2          U0FCR = 0x07;                  /* Enable and reset TX and RX FIFO. */
  495   2          U0LCR |= 0x80;  
  496   2          if ( Data == 0x01 ) {
  497   3              U0DLL = 0x20;
  498   3              U0DLM = 0x00;
  499   3          }
  500   2          else if ( Data == 0x02 ) {
  501   3              U0DLL = 0x41;
  502   3              U0DLM = 0x00;
  503   3          }
  504   2          else if ( Data == 0x03 ) {
  505   3              U0DLL = 0x61;
  506   3              U0DLM = 0x00;
  507   3          }
  508   2          else if ( Data == 0x06 ) {
  509   3              U0DLL = 0xC3;
  510   3              U0DLM = 0x00;
  511   3          }
  512   2          else if ( Data == 0x0C ) {
  513   3              U0DLL = 0x86;
  514   3              U0DLM = 0x01;
  515   3          }   
  516   2          U0LCR &= ~0x80;
  517   2        }
  518   1        else if ( channelNum == 1 ) {
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 9   

  519   2          U1FCR = 0x07;                  /* Enable and reset TX and RX FIFO. */
  520   2          U1LCR |= 0x80;
  521   2          if ( Data == 0x01 ) {
  522   3              U1DLL = 0x20;
  523   3              U1DLM = 0x00;
  524   3          }
  525   2          else if ( Data == 0x02 ) {
  526   3              U1DLL = 0x41;
  527   3              U1DLM = 0x00;
  528   3          }
  529   2          else if ( Data == 0x03 ) {
  530   3              U1DLL = 0x61;
  531   3              U1DLM = 0x00;
  532   3          }
  533   2          else if ( Data == 0x06 ) {
  534   3              U1DLL = 0xC3;
  535   3              U1DLM = 0x00;
  536   3          }
  537   2          else if ( Data == 0x0C ) {
  538   3              U1DLL = 0x86;
  539   3              U1DLM = 0x01;
  540   3          }
  541   2          U1LCR &= ~0x80;
  542   2        }
  543   1      }
  544          
  545          void SetSIOStopBit( BYTE channelNum, BYTE ConfigValue )
  546          {
  547   1        BYTE lcr;
  548   1      
  549   1        /* 0 is 1 stop bit, 1 is 2 stop bits, bit2 on LCR is stop bit setting */
  550   1        if ( channelNum == 0 ) {
  551   2          lcr = U0LCR & 0xFB;
  552   2          U0LCR = lcr | (ConfigValue << 2);           
  553   2        }
  554   1        else if ( channelNum == 1 ) {
  555   2          lcr = U1LCR & 0xFB;
  556   2          U1LCR = lcr | (ConfigValue << 2);
  557   2        }
  558   1      }
  559          
  560          void SetSIODataBit( BYTE channelNum, BYTE ConfigValue )
  561          {
  562   1        BYTE lcr;
  563   1      
  564   1        if ( channelNum == 0 ) {
  565   2          lcr = U0LCR & 0xFC;
  566   2          U0LCR = lcr | ConfigValue;          
  567   2        }
  568   1        else if ( channelNum == 1 ) {
  569   2          lcr = U1LCR & 0xFC;
  570   2          U1LCR = lcr | ConfigValue;
  571   2        }
  572   1      }
  573          
  574          void SetSIOParity( BYTE channelNum, BYTE ConfigValue )
  575          {
  576   1        BYTE lcr;
  577   1      
  578   1        if ( channelNum == 0 ) {
  579   2              lcr = U0LCR & 0xCF;
  580   2              U0LCR = lcr | (ConfigValue << 4);
  581   2        }
  582   1        else if ( channelNum == 1 ) {
  583   2              lcr = U1LCR & 0xCF;
  584   2              U1LCR = lcr | (ConfigValue << 4);
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 10  

  585   2        }
  586   1      }
  587          
  588          void SetSIOFlowControl( BYTE channelNum, BYTE ConfigValue )
  589          {
  590   1        /* NO flow control setting is neceaasry, unlike the UART on x51 */ 
  591   1        if ( channelNum == 0 ) {
  592   2          ConfigValue = ConfigValue;          
  593   2        }
  594   1        else if ( channelNum == 1 ) {
  595   2          ConfigValue = ConfigValue;
  596   2        }
  597   1      }
  598          
  599          void SetSIODTR( BYTE channelNum, BYTE ConfigValue )
  600          {
  601   1        BYTE mcr;
  602   1        /* only apply to channel 1 */
  603   1        if ( channelNum == 1 ) {
  604   2          mcr = U1MCR & 0xFE;
  605   2          U1MCR = mcr | ConfigValue;
  606   2        }
  607   1      }
  608          
  609          void SetSIORTS( BYTE channelNum, BYTE ConfigValue )
  610          {
  611   1        BYTE mcr;
  612   1      
  613   1        /* only apply to channel 1 */
  614   1        if ( channelNum == 1 ) {
  615   2          mcr = U1MCR & 0xFD;
  616   2          U1MCR = mcr | (ConfigValue << 1);
  617   2        }
  618   1      }
  619          
  620          void GetSIOModemStatus( BYTE channelNum )
  621          {
  622   1        channelNum = channelNum;
  623   1      }
  624          
  625          /*
  626           *  VCOM Get SIO Setup Request Callback
  627           *    Parameters:      None (global SetupPacket and EP0Buf)
  628           *    Return Value:    TRUE - Success, FALSE - Error
  629           */
  630          
  631          BOOL VCOM_GetSIOSetup (void) {
  632   1        /* Get SIO setup from the device, not supported */
  633   1        return (TRUE);  
  634   1      }
  635          
  636          
  637          /*
  638           *  VCOM Set SIO Setup Request Callback
  639           *    Parameters:      None (global SetupPacket and EP0Buf)
  640           *    Return Value:    TRUE - Success, FALSE - Error
  641           */
  642          
  643          BOOL VCOM_SetSIOSetup( BYTE Cmd, BYTE Data ) {
  644   1        
  645   1        BYTE ChannelNum;
  646   1      
  647   1        /* Set SIO configuration, baudrate, data bits, stop bits, parity, flow control, 
  648   1        based on the info. from the host */
  649   1        if ( !(Cmd & 0x20) )
  650   1          ChannelNum = 0;
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 11  

  651   1        else
  652   1          ChannelNum = 1;
  653   1      
  654   1        Cmd &= ~0x20;         /* clear bit 5, use all cmd for channel 0 */
  655   1        switch ( Cmd ) {
  656   2          case BAUDRATE_SETUP:
  657   2            SetSIOBaudrate( ChannelNum, Data );
  658   2            break;
  659   2          case STOPBIT_SETUP:
  660   2              SetSIOStopBit( ChannelNum, Data );
  661   2            break;          
  662   2          case DATABIT_SETUP:
  663   2              SetSIODataBit( ChannelNum, Data );
  664   2            break;
  665   2          case PARITY_SETUP:
  666   2              SetSIOParity( ChannelNum, Data );
  667   2            break;
  668   2          case FLOWCTRL_SETUP:
  669   2              SetSIOFlowControl( ChannelNum, Data );
  670   2            break;
  671   2          case DTR_SETUP:
  672   2              SetSIODTR( ChannelNum, Data );
  673   2            break;
  674   2          case RTS_SETUP:
  675   2              SetSIORTS( ChannelNum, Data );
  676   2            break;
  677   2          case HARDCODE_SETUP:
  678   2            break;
  679   2          case MODEM_SETUP:
  680   2              GetSIOModemStatus( ChannelNum );
  681   2            break;
  682   2          default:
  683   2            // EP0Buf[] = ...;
  684   2            // break;
  685   2            return (FALSE);
  686   2        }
  687   1        return (TRUE);
  688   1      }
  689          
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 12  

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (strlen?T)
 EXTERN CODE16 (memcpy?T)
 EXTERN CODE16 (USB_ReadEP?T)
 EXTERN CODE16 (USB_WriteEP?T)
 EXTERN DATA (USB_Configuration)
 EXTERN CODE16 (USB_ResetCore?T)
 EXTERN CODE16 (USB_EndPoint0?T)



*** PUBLICS:
 PUBLIC         USB_Reset_Event?T
 PUBLIC         DeviceData2UART?T
 PUBLIC         DeviceData2Host?T
 PUBLIC         USB_EndPoint1?T
 PUBLIC         USB_EndPoint2?T
 PUBLIC         USB_EndPoint3?T
 PUBLIC         USB_EndPoint4?T
 PUBLIC         USB_EndPoint5?T
 PUBLIC         USB_EndPoint6?T
 PUBLIC         USB_EndPoint7?T
 PUBLIC         USB_EndPoint8?T
 PUBLIC         USB_EndPoint9?T
 PUBLIC         USB_EndPoint10?T
 PUBLIC         USB_EndPoint11?T
 PUBLIC         USB_EndPoint12?T
 PUBLIC         USB_EndPoint13?T
 PUBLIC         USB_EndPoint14?T
 PUBLIC         USB_EndPoint15?T
 PUBLIC         USB_Configure_Event?T
 PUBLIC         init_serial?T
 PUBLIC         putchar?T
 PUBLIC         getchar?T
 PUBLIC         VCOM_SetSIOSetup?T
 PUBLIC         VCOM_GetSIOSetup?T
 PUBLIC         SetSIOBaudrate?T
 PUBLIC         SetSIOStopBit?T
 PUBLIC         SetSIODataBit?T
 PUBLIC         SetSIOParity?T
 PUBLIC         SetSIOFlowControl?T
 PUBLIC         SetSIODTR?T
 PUBLIC         SetSIORTS?T
 PUBLIC         GetSIOModemStatus?T
 PUBLIC         USB_P_EP
 PUBLIC         ReportStatus0
 PUBLIC         ReportStatus1
 PUBLIC         Data2Host0
 PUBLIC         Data2Host1
 PUBLIC         RxLength0
 PUBLIC         RxLength1
 PUBLIC         USB2UARTBuf0
 PUBLIC         USB2UARTBuf1
 PUBLIC         UART2USBBuf0
 PUBLIC         UART2USBBuf1



*** DATA SEGMENT '?DT0?VCOMuser':
 00000000          USB_P_EP:
 00000000           BEGIN_INIT
 00000000  00000000  DD          USB_EndPoint0?T
 00000004  00000000  DD          USB_EndPoint1?T
 00000008  00000000  DD          USB_EndPoint2?T
 0000000C  00000000  DD          USB_EndPoint3?T
 00000010  00000000  DD          USB_EndPoint4?T
 00000014  00000000  DD          USB_EndPoint5?T
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 13  

 00000018  00000000  DD          0x0
 0000001C  00000000  DD          0x0
 00000020  00000000  DD          0x0
 00000024  00000000  DD          0x0
 00000028  00000000  DD          0x0
 0000002C  00000000  DD          0x0
 00000030  00000000  DD          0x0
 00000034  00000000  DD          0x0
 00000038  00000000  DD          0x0
 0000003C  00000000  DD          0x0
 00000040           END_INIT
 00000040          KeyPressed:
 00000040           BEGIN_INIT
 00000040  00        DB          0x0
 00000041           END_INIT
 00000041          ReportStatus0:
 00000041           BEGIN_INIT
 00000041  00        DB          0x0
 00000042           END_INIT
 00000042          ReportStatus1:
 00000042           BEGIN_INIT
 00000042  00        DB          0x0
 00000043           END_INIT
 00000043          Data2Host0:
 00000043           BEGIN_INIT
 00000043  00        DB          0x0
 00000044           END_INIT
 00000044          Data2Host1:
 00000044           BEGIN_INIT
 00000044  00        DB          0x0
 00000045           END_INIT
 00000045          RxLength0:
 00000045            DS          1
 00000046          RxLength1:
 00000046            DS          1
 00000047          USB2UARTBuf0:
 00000047            DS          64
 00000087          USB2UARTBuf1:
 00000087            DS          64
 000000C7          UART2USBBuf0:
 000000C7            DS          64
 00000107          UART2USBBuf1:
 00000107            DS          64

*** DATA SEGMENT '?CON?VCOMuser':
 00000000          ?tpl?0001:
 00000000           BEGIN_INIT
 00000000            DB          'SW1 pressed',0x0D,0x0A,0x00
 0000000E           END_INIT
 0000000E            ALIGN       4
 00000010          ?tpl?0002:
 00000010           BEGIN_INIT
 00000010            DB          'SW2 pressed',0x0D,0x0A,0x00
 0000001E           END_INIT
 0000001E            ALIGN       4
 00000020          ?tpl?0003:
 00000020           BEGIN_INIT
 00000020            DB          'SW3 pressed',0x0D,0x0A,0x00
 0000002E           END_INIT
 0000002E            ALIGN       4
 00000030          ?tpl?0004:
 00000030           BEGIN_INIT
 00000030            DB          'SW4 pressed',0x0D,0x0A,0x00
 0000003E           END_INIT



*** CODE SEGMENT '?PR?DeviceData2UART?T?VCOMuser':
   34: void DeviceData2UART( BYTE portNum )
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 14  

 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C06      MOV         R6,R0 ; portNum
 00000004  ---- Variable 'portNum' assigned to Register 'R6' ----
 00000004  ---- Variable 'pData' assigned to Register 'R5' ----
 00000004  ---- Variable 'cnt' assigned to Register 'R4' ----
   35: {
 00000004            ; SCOPE-START
   40:   if ( portNum == 0 )                   //if Data is being send from COMx
 00000004  1C30      MOV         R0,R6 ; portNum
 00000006  0600      LSL         R0,R0,#0x18 ; portNum
 00000008  0E00      LSR         R0,R0,#0x18
 0000000A  2800      CMP         R0,#0x0
 0000000C  D13B      BNE         L_1  ; T=0x00000086
   42:     pData = &USB2UARTBuf0[0];
 0000000E  4800      LDR         R5,=USB2UARTBuf0 ; USB2UARTBuf0
   43:     cnt = USB_ReadEP(0x02, pData);
 00000010  1C29      MOV         R1,R5 ; pData
 00000012  2002      MOV         R0,#0x2
 00000014  F7FF      BL          USB_ReadEP?T  ; T=0x0001  (1)
 00000016  FFF4      BL          USB_ReadEP?T  ; T=0x0001  (2)
 00000018  1C04      MOV         R4,R0 ; cnt
   44:     switch(*pData)
 0000001A  1C28      MOV         R0,R5 ; pData
 0000001C  7800      LDRB        R0,[R0,#0x0] ; pData
 0000001E  2832      CMP         R0,#0x32
 00000020  D010      BEQ         L_5  ; T=0x00000044
 00000022  2833      CMP         R0,#0x33
 00000024  D019      BEQ         L_6  ; T=0x0000005A
 00000026  2834      CMP         R0,#0x34
 00000028  D022      BEQ         L_7  ; T=0x00000070
 0000002A  2831      CMP         R0,#0x31
 0000002C  D136      BNE         L_16  ; T=0x0000009C
   46:      case '1': 
 0000002E          L_3:
   48:          if(IOPIN1 & 0x00010000)
 0000002E  4800      LDR         R0,=0xE0028010
 00000030  6800      LDR         R0,[R0,#0x0]
 00000032  4800      LDR         R1,=0x10000
 00000034  4208      TST         R0,R1
 00000036  D002      BEQ         L_8  ; T=0x0000003E
   49:             {IOCLR1 = 0x00010000;}
 00000038  4800      LDR         R0,=0xE002801C
 0000003A  6001      STR         R1,[R0,#0x0]
 0000003C  E02E      B           L_16  ; T=0x0000009C
 0000003E          L_8:
   51:             {IOSET1 = 0x00010000;}
 0000003E  4800      LDR         R0,=0xE0028014
 00000040  6001      STR         R1,[R0,#0x0]
   52:         break;
 00000042  E02B      B           L_16  ; T=0x0000009C
   54:      case '2': 
 00000044          L_5:
   56:          if(IOPIN1 & 0x00020000)
 00000044  4800      LDR         R0,=0xE0028010
 00000046  6800      LDR         R0,[R0,#0x0]
 00000048  4800      LDR         R1,=0x20000
 0000004A  4208      TST         R0,R1
 0000004C  D002      BEQ         L_10  ; T=0x00000054
   57:             {IOCLR1 = 0x00020000;}
 0000004E  4800      LDR         R0,=0xE002801C
 00000050  6001      STR         R1,[R0,#0x0]
 00000052  E023      B           L_16  ; T=0x0000009C
 00000054          L_10:
   59:             {IOSET1 = 0x00020000;}
 00000054  4800      LDR         R0,=0xE0028014
 00000056  6001      STR         R1,[R0,#0x0]
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 15  

   60:         break;
 00000058  E020      B           L_16  ; T=0x0000009C
   62:      case '3': 
 0000005A          L_6:
   64:          if(IOPIN1 & 0x00040000)
 0000005A  4800      LDR         R0,=0xE0028010
 0000005C  6800      LDR         R0,[R0,#0x0]
 0000005E  4800      LDR         R1,=0x40000
 00000060  4208      TST         R0,R1
 00000062  D002      BEQ         L_12  ; T=0x0000006A
   65:             {IOCLR1 = 0x00040000;}
 00000064  4800      LDR         R0,=0xE002801C
 00000066  6001      STR         R1,[R0,#0x0]
 00000068  E018      B           L_16  ; T=0x0000009C
 0000006A          L_12:
   67:             {IOSET1 = 0x00040000;}
 0000006A  4800      LDR         R0,=0xE0028014
 0000006C  6001      STR         R1,[R0,#0x0]
   68:         break;
 0000006E  E015      B           L_16  ; T=0x0000009C
   70:      case '4': 
 00000070          L_7:
   72:          if(IOPIN1 & 0x00080000)                                                                          
 00000070  4800      LDR         R0,=0xE0028010
 00000072  6800      LDR         R0,[R0,#0x0]
 00000074  4800      LDR         R1,=0x80000
 00000076  4208      TST         R0,R1
 00000078  D002      BEQ         L_14  ; T=0x00000080
   73:             {IOCLR1 = 0x00080000;}
 0000007A  4800      LDR         R0,=0xE002801C
 0000007C  6001      STR         R1,[R0,#0x0]
 0000007E  E00D      B           L_16  ; T=0x0000009C
 00000080          L_14:
   75:             {IOSET1 = 0x00080000;}
 00000080  4800      LDR         R0,=0xE0028014
 00000082  6001      STR         R1,[R0,#0x0]
   76:         break;
 00000084  E00A      B           L_16  ; T=0x0000009C
   83:   }
 00000086          L_1:
   84:   else if ( portNum == 1 )               //if Data is being send from COMx+1
 00000086  1C30      MOV         R0,R6 ; portNum
 00000088  0600      LSL         R0,R0,#0x18 ; portNum
 0000008A  0E00      LSR         R0,R0,#0x18
 0000008C  2801      CMP         R0,#0x1
 0000008E  D105      BNE         L_16  ; T=0x0000009C
   86:     pData = &USB2UARTBuf1[0];
 00000090  4800      LDR         R5,=USB2UARTBuf1 ; USB2UARTBuf1
   87:     cnt = USB_ReadEP(0x05, pData);
 00000092  1C29      MOV         R1,R5 ; pData
 00000094  2005      MOV         R0,#0x5
 00000096  F7FF      BL          USB_ReadEP?T  ; T=0x0001  (1)
 00000098  FFB3      BL          USB_ReadEP?T  ; T=0x0001  (2)
 0000009A  1C04      MOV         R4,R0 ; cnt
   88:   }
 0000009C          L_16:
   89:   return;
 0000009C            ; SCOPE-END
   90: }
 0000009C  BC70      POP         {R4-R6}
 0000009E  BC08      POP         {R3}
 000000A0  4718      BX          R3
 000000A2          ENDP ; 'DeviceData2UART?T'


*** CODE SEGMENT '?PR?DeviceData2Host?T?VCOMuser':
   92: void DeviceData2Host( BYTE portNum )
 00000000  B530      PUSH        {R4-R5,LR}
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 16  

 00000002  B090      SUB         R13,#0x40
 00000004  ---- Variable 'length' assigned to Register 'R4' ----
   93: {
 00000004            ; SCOPE-START
   94:  const BYTE msg1[] = "SW1 pressed\r\n";
 00000004  4800      LDR         R1,=?tpl?0001 ; ?tpl?0001
 00000006  A800      ADD         R0,R13,#0x0
 00000008  220E      MOV         R2,#0xE
 0000000A          L_117:
 0000000A  780B      LDRB        R3,[R1,#0x0]
 0000000C  7003      STRB        R3,[R0,#0x0]
 0000000E  1C49      ADD         R1,R1,#0x1
 00000010  1C40      ADD         R0,R0,#0x1
 00000012  1E52      SUB         R2,R2,#0x1
 00000014  D1F9      BNE         L_117  ; T=0x0000000A
   95:  const BYTE msg2[] = "SW2 pressed\r\n";
 00000016  4800      LDR         R1,=?tpl?0002 ; ?tpl?0002
 00000018  A804      ADD         R0,R13,#0x10
 0000001A  220E      MOV         R2,#0xE
 0000001C          L_118:
 0000001C  780B      LDRB        R3,[R1,#0x0]
 0000001E  7003      STRB        R3,[R0,#0x0]
 00000020  1C49      ADD         R1,R1,#0x1
 00000022  1C40      ADD         R0,R0,#0x1
 00000024  1E52      SUB         R2,R2,#0x1
 00000026  D1F9      BNE         L_118  ; T=0x0000001C
   96:  const BYTE msg3[] = "SW3 pressed\r\n";
 00000028  4800      LDR         R1,=?tpl?0003 ; ?tpl?0003
 0000002A  A808      ADD         R0,R13,#0x20
 0000002C  220E      MOV         R2,#0xE
 0000002E          L_119:
 0000002E  780B      LDRB        R3,[R1,#0x0]
 00000030  7003      STRB        R3,[R0,#0x0]
 00000032  1C49      ADD         R1,R1,#0x1
 00000034  1C40      ADD         R0,R0,#0x1
 00000036  1E52      SUB         R2,R2,#0x1
 00000038  D1F9      BNE         L_119  ; T=0x0000002E
   97:  const BYTE msg4[] = "SW4 pressed\r\n";
 0000003A  4800      LDR         R1,=?tpl?0004 ; ?tpl?0004
 0000003C  A80C      ADD         R0,R13,#0x30
 0000003E  220E      MOV         R2,#0xE
 00000040          L_120:
 00000040  780B      LDRB        R3,[R1,#0x0]
 00000042  7003      STRB        R3,[R0,#0x0]
 00000044  1C49      ADD         R1,R1,#0x1
 00000046  1C40      ADD         R0,R0,#0x1
 00000048  1E52      SUB         R2,R2,#0x1
 0000004A  D1F9      BNE         L_120  ; T=0x00000040
  101:   if (!SW1 && !KeyPressed)              /* Check if S2 is pressed */
 0000004C  4800      LDR         R0,=0xE0028000
 0000004E  6800      LDR         R0,[R0,#0x0]
 00000050  4800      LDR         R1,=0x8000
 00000052  4208      TST         R0,R1
 00000054  D11D      BNE         L_19  ; T=0x00000092
 00000056  4800      LDR         R0,=KeyPressed ; KeyPressed
 00000058  7800      LDRB        R0,[R0,#0x0] ; KeyPressed
 0000005A  2800      CMP         R0,#0x0
 0000005C  D119      BNE         L_19  ; T=0x00000092
  103:    KeyPressed = 1;
 0000005E  2101      MOV         R1,#0x1
 00000060  4800      LDR         R0,=KeyPressed ; KeyPressed
 00000062  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  104:    length = strlen(msg1);
 00000064  AD00      ADD         R5,R13,#0x0
 00000066  1C28      MOV         R0,R5
 00000068  F7FF      BL          strlen?T  ; T=0x0001  (1)
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 17  

 0000006A  FFCA      BL          strlen?T  ; T=0x0001  (2)
 0000006C  0604      LSL         R4,R0,#0x18 ; strlen?T
 0000006E  0E24      LSR         R4,R4,#0x18
  105:    memcpy( UART2USBBuf0, msg1, length );
 00000070  1C20      MOV         R0,R4 ; length
 00000072  0602      LSL         R2,R0,#0x18 ; length
 00000074  0E12      LSR         R2,R2,#0x18
 00000076  4800      LDR         R0,=UART2USBBuf0 ; UART2USBBuf0
 00000078  1C29      MOV         R1,R5
 0000007A  F7FF      BL          memcpy?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          memcpy?T  ; T=0x0001  (2)
  106:    USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
 0000007E  1C20      MOV         R0,R4 ; length
 00000080  0602      LSL         R2,R0,#0x18 ; length
 00000082  0E12      LSR         R2,R2,#0x18
 00000084  4800      LDR         R1,=UART2USBBuf0 ; UART2USBBuf0
 00000086  2082      MOV         R0,#0x82
 00000088  F7FF      BL          USB_WriteEP?T  ; T=0x0001  (1)
 0000008A  FFBA      BL          USB_WriteEP?T  ; T=0x0001  (2)
  107:    KeyPressed = 0;
 0000008C  2100      MOV         R1,#0x0
 0000008E  4800      LDR         R0,=KeyPressed ; KeyPressed
 00000090  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  108:   }
 00000092          L_19:
  109:   if (!SW2 && !KeyPressed)              /* Check if S2 is pressed */
 00000092  4800      LDR         R0,=0xE0028000
 00000094  6800      LDR         R0,[R0,#0x0]
 00000096  4800      LDR         R1,=0x2000
 00000098  4208      TST         R0,R1
 0000009A  D11D      BNE         L_20  ; T=0x000000D8
 0000009C  4800      LDR         R0,=KeyPressed ; KeyPressed
 0000009E  7800      LDRB        R0,[R0,#0x0] ; KeyPressed
 000000A0  2800      CMP         R0,#0x0
 000000A2  D119      BNE         L_20  ; T=0x000000D8
  111:    KeyPressed = 1;
 000000A4  2101      MOV         R1,#0x1
 000000A6  4800      LDR         R0,=KeyPressed ; KeyPressed
 000000A8  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  112:    length = strlen(msg2);
 000000AA  AD04      ADD         R5,R13,#0x10
 000000AC  1C28      MOV         R0,R5
 000000AE  F7FF      BL          strlen?T  ; T=0x0001  (1)
 000000B0  FFA7      BL          strlen?T  ; T=0x0001  (2)
 000000B2  0604      LSL         R4,R0,#0x18 ; strlen?T
 000000B4  0E24      LSR         R4,R4,#0x18
  113:    memcpy( UART2USBBuf0, msg2, length );
 000000B6  1C20      MOV         R0,R4 ; length
 000000B8  0602      LSL         R2,R0,#0x18 ; length
 000000BA  0E12      LSR         R2,R2,#0x18
 000000BC  4800      LDR         R0,=UART2USBBuf0 ; UART2USBBuf0
 000000BE  1C29      MOV         R1,R5
 000000C0  F7FF      BL          memcpy?T  ; T=0x0001  (1)
 000000C2  FF9E      BL          memcpy?T  ; T=0x0001  (2)
  114:    USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
 000000C4  1C20      MOV         R0,R4 ; length
 000000C6  0602      LSL         R2,R0,#0x18 ; length
 000000C8  0E12      LSR         R2,R2,#0x18
 000000CA  4800      LDR         R1,=UART2USBBuf0 ; UART2USBBuf0
 000000CC  2082      MOV         R0,#0x82
 000000CE  F7FF      BL          USB_WriteEP?T  ; T=0x0001  (1)
 000000D0  FF97      BL          USB_WriteEP?T  ; T=0x0001  (2)
  115:    KeyPressed = 0;
 000000D2  2100      MOV         R1,#0x0
 000000D4  4800      LDR         R0,=KeyPressed ; KeyPressed
 000000D6  7001      STRB        R1,[R0,#0x0] ; KeyPressed
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 18  

  116:   }
 000000D8          L_20:
  117:   if (!SW3 && !KeyPressed)              /* Check if S2 is pressed */
 000000D8  4800      LDR         R0,=0xE0028000
 000000DA  6800      LDR         R0,[R0,#0x0]
 000000DC  4800      LDR         R1,=0x1000
 000000DE  4208      TST         R0,R1
 000000E0  D11D      BNE         L_21  ; T=0x0000011E
 000000E2  4800      LDR         R0,=KeyPressed ; KeyPressed
 000000E4  7800      LDRB        R0,[R0,#0x0] ; KeyPressed
 000000E6  2800      CMP         R0,#0x0
 000000E8  D119      BNE         L_21  ; T=0x0000011E
  119:    KeyPressed = 1;
 000000EA  2101      MOV         R1,#0x1
 000000EC  4800      LDR         R0,=KeyPressed ; KeyPressed
 000000EE  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  120:    length = strlen(msg3);
 000000F0  AD08      ADD         R5,R13,#0x20
 000000F2  1C28      MOV         R0,R5
 000000F4  F7FF      BL          strlen?T  ; T=0x0001  (1)
 000000F6  FF84      BL          strlen?T  ; T=0x0001  (2)
 000000F8  0604      LSL         R4,R0,#0x18 ; strlen?T
 000000FA  0E24      LSR         R4,R4,#0x18
  121:    memcpy( UART2USBBuf0, msg3, length );
 000000FC  1C20      MOV         R0,R4 ; length
 000000FE  0602      LSL         R2,R0,#0x18 ; length
 00000100  0E12      LSR         R2,R2,#0x18
 00000102  4800      LDR         R0,=UART2USBBuf0 ; UART2USBBuf0
 00000104  1C29      MOV         R1,R5
 00000106  F7FF      BL          memcpy?T  ; T=0x0001  (1)
 00000108  FF7B      BL          memcpy?T  ; T=0x0001  (2)
  122:    USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
 0000010A  1C20      MOV         R0,R4 ; length
 0000010C  0602      LSL         R2,R0,#0x18 ; length
 0000010E  0E12      LSR         R2,R2,#0x18
 00000110  4800      LDR         R1,=UART2USBBuf0 ; UART2USBBuf0
 00000112  2082      MOV         R0,#0x82
 00000114  F7FF      BL          USB_WriteEP?T  ; T=0x0001  (1)
 00000116  FF74      BL          USB_WriteEP?T  ; T=0x0001  (2)
  123:    KeyPressed = 0;
 00000118  2100      MOV         R1,#0x0
 0000011A  4800      LDR         R0,=KeyPressed ; KeyPressed
 0000011C  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  124:   }
 0000011E          L_21:
  125:   if (!SW4 && !KeyPressed)              /* Check if S2 is pressed */
 0000011E  4800      LDR         R0,=0xE0028000
 00000120  6800      LDR         R0,[R0,#0x0]
 00000122  4800      LDR         R1,=0x40000000
 00000124  4208      TST         R0,R1
 00000126  D11D      BNE         L_22  ; T=0x00000164
 00000128  4800      LDR         R0,=KeyPressed ; KeyPressed
 0000012A  7800      LDRB        R0,[R0,#0x0] ; KeyPressed
 0000012C  2800      CMP         R0,#0x0
 0000012E  D119      BNE         L_22  ; T=0x00000164
  127:    KeyPressed = 1;
 00000130  2101      MOV         R1,#0x1
 00000132  4800      LDR         R0,=KeyPressed ; KeyPressed
 00000134  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  128:    length = strlen(msg4);
 00000136  AD0C      ADD         R5,R13,#0x30
 00000138  1C28      MOV         R0,R5
 0000013A  F7FF      BL          strlen?T  ; T=0x0001  (1)
 0000013C  FF61      BL          strlen?T  ; T=0x0001  (2)
 0000013E  0604      LSL         R4,R0,#0x18 ; strlen?T
 00000140  0E24      LSR         R4,R4,#0x18
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 19  

  129:    memcpy( UART2USBBuf0, msg4, length );
 00000142  1C20      MOV         R0,R4 ; length
 00000144  0602      LSL         R2,R0,#0x18 ; length
 00000146  0E12      LSR         R2,R2,#0x18
 00000148  4800      LDR         R0,=UART2USBBuf0 ; UART2USBBuf0
 0000014A  1C29      MOV         R1,R5
 0000014C  F7FF      BL          memcpy?T  ; T=0x0001  (1)
 0000014E  FF58      BL          memcpy?T  ; T=0x0001  (2)
  130:    USB_WriteEP(0x80 | 0x02, &UART2USBBuf0[0], length );
 00000150  1C20      MOV         R0,R4 ; length
 00000152  0602      LSL         R2,R0,#0x18 ; length
 00000154  0E12      LSR         R2,R2,#0x18
 00000156  4800      LDR         R1,=UART2USBBuf0 ; UART2USBBuf0
 00000158  2082      MOV         R0,#0x82
 0000015A  F7FF      BL          USB_WriteEP?T  ; T=0x0001  (1)
 0000015C  FF51      BL          USB_WriteEP?T  ; T=0x0001  (2)
  131:    KeyPressed = 0;
 0000015E  2100      MOV         R1,#0x0
 00000160  4800      LDR         R0,=KeyPressed ; KeyPressed
 00000162  7001      STRB        R1,[R0,#0x0] ; KeyPressed
  132:   }
 00000164          L_22:
  135:  return;
 00000164            ; SCOPE-END
  136: }
 00000164  B010      ADD         R13,#0x40
 00000166  BC30      POP         {R4-R5}
 00000168  BC08      POP         {R3}
 0000016A  4718      BX          R3
 0000016C          ENDP ; 'DeviceData2Host?T'


*** CODE SEGMENT '?PR?USB_Reset_Event?T?VCOMuser':
  156: void USB_Reset_Event (void) {
 00000000  B500      PUSH        {LR}
  157:   USB_ResetCore();
 00000002  F7FF      BL          USB_ResetCore?T  ; T=0x0001  (1)
 00000004  FFFD      BL          USB_ResetCore?T  ; T=0x0001  (2)
  158: }
 00000006  BC08      POP         {R3}
 00000008  4718      BX          R3
 0000000A          ENDP ; 'USB_Reset_Event?T'


*** CODE SEGMENT '?PR?USB_Configure_Event?T?VCOMuser':
  220:   if (USB_Configuration) {             /* Check if USB is configured */
 00000000  4800      LDR         R0,=USB_Configuration ; USB_Configuration
 00000002  7800      LDRB        R0,[R0,#0x0] ; USB_Configuration
 00000004  2800      CMP         R0,#0x0
 00000006  D008      BEQ         L_24  ; T=0x0000001A
  221:     ReportStatus0 = ReportStatus1 = 1;
 00000008  2101      MOV         R1,#0x1
 0000000A  4800      LDR         R0,=ReportStatus1 ; ReportStatus1
 0000000C  7001      STRB        R1,[R0,#0x0] ; ReportStatus1
 0000000E  4800      LDR         R0,=ReportStatus0 ; ReportStatus0
 00000010  7001      STRB        R1,[R0,#0x0] ; ReportStatus0
  222:     Data2Host0 = Data2Host1 = 1;
 00000012  4800      LDR         R0,=Data2Host1 ; Data2Host1
 00000014  7001      STRB        R1,[R0,#0x0] ; Data2Host1
 00000016  4800      LDR         R0,=Data2Host0 ; Data2Host0
 00000018  7001      STRB        R1,[R0,#0x0] ; Data2Host0
  223:   }
 0000001A          L_24:
  224: }
 0000001A  4770      BX          R14
 0000001C          ENDP ; 'USB_Configure_Event?T'


*** CODE SEGMENT '?PR?USB_EndPoint1?T?VCOMuser':
  275: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint1?T'

ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 20  


*** CODE SEGMENT '?PR?USB_EndPoint2?T?VCOMuser':
  282: void USB_EndPoint2 (DWORD event) {
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; event
 00000004  ---- Variable 'event' assigned to Register 'R1' ----
  283:   switch (event) {
 00000004  1C08      MOV         R0,R1 ; event
 00000006  2802      CMP         R0,#0x2 ; event
 00000008  D005      BEQ         L_26  ; T=0x00000016
 0000000A  2803      CMP         R0,#0x3 ; event
 0000000C  D106      BNE         L_25  ; T=0x0000001C
  284:     case USB_EVT_IN:
 0000000E          L_27:
  285:       Data2Host0 = 1;
 0000000E  2101      MOV         R1,#0x1
 00000010  4800      LDR         R0,=Data2Host0 ; Data2Host0
 00000012  7001      STRB        R1,[R0,#0x0] ; Data2Host0
  286:       break;
 00000014  E002      B           L_25  ; T=0x0000001C
  287:     case USB_EVT_OUT:
 00000016          L_26:
  288:       DeviceData2UART( 0 );
 00000016  2000      MOV         R0,#0x0
 00000018  F7FF      BL          DeviceData2UART?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          DeviceData2UART?T  ; T=0x0001  (2)
  290:   }
 0000001C          L_25:
  292: }
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'USB_EndPoint2?T'


*** CODE SEGMENT '?PR?USB_EndPoint3?T?VCOMuser':
  302: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint3?T'


*** CODE SEGMENT '?PR?USB_EndPoint4?T?VCOMuser':
  311: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint4?T'


*** CODE SEGMENT '?PR?USB_EndPoint5?T?VCOMuser':
  318: void USB_EndPoint5 (DWORD event) {
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; event
 00000004  ---- Variable 'event' assigned to Register 'R1' ----
  319:   switch (event) {
 00000004  1C08      MOV         R0,R1 ; event
 00000006  2802      CMP         R0,#0x2 ; event
 00000008  D005      BEQ         L_29  ; T=0x00000016
 0000000A  2803      CMP         R0,#0x3 ; event
 0000000C  D106      BNE         L_28  ; T=0x0000001C
  320:     case USB_EVT_IN:
 0000000E          L_30:
  321:       Data2Host1 = 1;
 0000000E  2101      MOV         R1,#0x1
 00000010  4800      LDR         R0,=Data2Host1 ; Data2Host1
 00000012  7001      STRB        R1,[R0,#0x0] ; Data2Host1
  322:       break;
 00000014  E002      B           L_28  ; T=0x0000001C
  323:     case USB_EVT_OUT:
 00000016          L_29:
  324:       DeviceData2UART( 1 );
 00000016  2001      MOV         R0,#0x1
 00000018  F7FF      BL          DeviceData2UART?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          DeviceData2UART?T  ; T=0x0001  (2)
  326:   }
 0000001C          L_28:
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 21  

  328: }
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'USB_EndPoint5?T'


*** CODE SEGMENT '?PR?USB_EndPoint6?T?VCOMuser':
  337: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint6?T'


*** CODE SEGMENT '?PR?USB_EndPoint7?T?VCOMuser':
  347: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint7?T'


*** CODE SEGMENT '?PR?USB_EndPoint8?T?VCOMuser':
  357: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint8?T'


*** CODE SEGMENT '?PR?USB_EndPoint9?T?VCOMuser':
  367: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint9?T'


*** CODE SEGMENT '?PR?USB_EndPoint10?T?VCOMuser':
  377: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint10?T'


*** CODE SEGMENT '?PR?USB_EndPoint11?T?VCOMuser':
  387: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint11?T'


*** CODE SEGMENT '?PR?USB_EndPoint12?T?VCOMuser':
  396: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint12?T'


*** CODE SEGMENT '?PR?USB_EndPoint13?T?VCOMuser':
  406: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint13?T'


*** CODE SEGMENT '?PR?USB_EndPoint14?T?VCOMuser':
  416: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint14?T'


*** CODE SEGMENT '?PR?USB_EndPoint15?T?VCOMuser':
  426: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'USB_EndPoint15?T'


*** CODE SEGMENT '?PR?init_serial?T?VCOMuser':
  433: void init_serial (void)  {     /* Initialize Serial Interface       */
 00000000  B410      PUSH        {R4}
  437:   PINSEL0 = 0x00050005;        /* Enable RxD1 and TxD1, RxD0 and TxD0 */
 00000002  4800      LDR         R1,=0x50005
 00000004  4800      LDR         R0,=0xE002C000
 00000006  6001      STR         R1,[R0,#0x0]
  440:   U0LCR = 0x83;                /* 8 bits, no Parity, 1 Stop bit     */
 00000008  2483      MOV         R4,#0x83
 0000000A  4800      LDR         R0,=0xE000C00C
 0000000C  7004      STRB        R4,[R0,#0x0]
  441:   U0DLL = 97;                  /* 9600 Baud Rate @ 15MHz VPB Clock  */
 0000000E  2361      MOV         R3,#0x61
 00000010  4800      LDR         R0,=0xE000C000
 00000012  7003      STRB        R3,[R0,#0x0]
  442:   U0LCR = 0x03;                /* DLAB = 0                          */  
 00000014  2203      MOV         R2,#0x3
 00000016  4800      LDR         R0,=0xE000C00C
 00000018  7002      STRB        R2,[R0,#0x0]
  443:   U0FCR = 0x07;                /* Enable and reset TX and RX FIFO. */
 0000001A  2107      MOV         R1,#0x7
 0000001C  4800      LDR         R0,=0xE000C008
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 22  

 0000001E  7001      STRB        R1,[R0,#0x0]
  445:   U1LCR = 0x83;                /* 8 bits, no Parity, 1 Stop bit     */
 00000020  4800      LDR         R0,=0xE001000C
 00000022  7004      STRB        R4,[R0,#0x0]
  446:   U1DLL = 97;                  /* 9600 Baud Rate @ 15MHz VPB Clock  */
 00000024  4800      LDR         R0,=0xE0010000
 00000026  7003      STRB        R3,[R0,#0x0]
  447:   U1LCR = 0x03;                /* DLAB = 0                          */
 00000028  4800      LDR         R0,=0xE001000C
 0000002A  7002      STRB        R2,[R0,#0x0]
  448:   U1FCR = 0x07;                /* Enable and reset TX and RX FIFO. */
 0000002C  4800      LDR         R0,=0xE0010008
 0000002E  7001      STRB        R1,[R0,#0x0]
  449: }
 00000030  BC10      POP         {R4}
 00000032  4770      BX          R14
 00000034          ENDP ; 'init_serial?T'


*** CODE SEGMENT '?PR?putchar?T?VCOMuser':
  451: int putchar(BYTE portNum, int ch)  {     /* Write character to Serial Port    */
 00000000  ---- Variable 'ch' assigned to Register 'R1' ----
 00000000  1C02      MOV         R2,R0 ; portNum
 00000002  ---- Variable 'portNum' assigned to Register 'R2' ----
  453:   if ( portNum == 0 ) {
 00000002  1C10      MOV         R0,R2 ; portNum
 00000004  0600      LSL         R0,R0,#0x18 ; portNum
 00000006  0E00      LSR         R0,R0,#0x18
 00000008  2800      CMP         R0,#0x0
 0000000A  D117      BNE         L_31  ; T=0x0000003C
  454:     if (ch == '\n')  {
 0000000C  1C08      MOV         R0,R1 ; ch
 0000000E  280A      CMP         R0,#0xA ; ch
 00000010  D107      BNE         L_40  ; T=0x00000022
  455:         while (!(U0LSR & 0x20));
 00000012          L_33:
 00000012  4800      LDR         R0,=0xE000C014
 00000014  7800      LDRB        R0,[R0,#0x0]
 00000016  2220      MOV         R2,#0x20
 00000018  4210      TST         R0,R2
 0000001A  D0FA      BEQ         L_33  ; T=0x00000012
  456:         U0THR = CR;                          /* output CR */
 0000001C  220D      MOV         R2,#0xD
 0000001E  4800      LDR         R0,=0xE000C000
 00000020  7002      STRB        R2,[R0,#0x0]
  458:     while (!(U0LSR & 0x20));
 00000022          L_40:
 00000022          L_37:
 00000022  4800      LDR         R0,=0xE000C014
 00000024  7800      LDRB        R0,[R0,#0x0]
 00000026  2220      MOV         R2,#0x20
 00000028  4210      TST         R0,R2
 0000002A  D0FA      BEQ         L_37  ; T=0x00000022
  459:     return (U0THR = ch);
 0000002C  1C08      MOV         R0,R1 ; ch
 0000002E  0600      LSL         R0,R0,#0x18 ; ch
 00000030  0E00      LSR         R0,R0,#0x18
 00000032  4800      LDR         R2,=0xE000C000
 00000034  7010      STRB        R0,[R2,#0x0]
 00000036  0600      LSL         R0,R0,#0x18
 00000038  0E00      LSR         R0,R0,#0x18
 0000003A  E016      B           L_41  ; T=0x0000006A
  460:   }
 0000003C          L_31:
  462:     if (ch == '\n')  {
 0000003C  1C08      MOV         R0,R1 ; ch
 0000003E  280A      CMP         R0,#0xA ; ch
 00000040  D107      BNE         L_51  ; T=0x00000052
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 23  

  463:         while (!(U1LSR & 0x20));
 00000042          L_44:
 00000042  4800      LDR         R0,=0xE0010014
 00000044  7800      LDRB        R0,[R0,#0x0]
 00000046  2220      MOV         R2,#0x20
 00000048  4210      TST         R0,R2
 0000004A  D0FA      BEQ         L_44  ; T=0x00000042
  464:         U1THR = CR;                          /* output CR */
 0000004C  220D      MOV         R2,#0xD
 0000004E  4800      LDR         R0,=0xE0010000
 00000050  7002      STRB        R2,[R0,#0x0]
  466:     while (!(U1LSR & 0x20));
 00000052          L_51:
 00000052          L_48:
 00000052  4800      LDR         R0,=0xE0010014
 00000054  7800      LDRB        R0,[R0,#0x0]
 00000056  2220      MOV         R2,#0x20
 00000058  4210      TST         R0,R2
 0000005A  D0FA      BEQ         L_48  ; T=0x00000052
  467:     return (U1THR = ch);
 0000005C  1C08      MOV         R0,R1 ; ch
 0000005E  0600      LSL         R0,R0,#0x18 ; ch
 00000060  0E00      LSR         R0,R0,#0x18
 00000062  4800      LDR         R1,=0xE0010000
 00000064  7008      STRB        R0,[R1,#0x0]
 00000066  0600      LSL         R0,R0,#0x18
 00000068  0E00      LSR         R0,R0,#0x18
  469: }
 0000006A          L_41:
 0000006A  4770      BX          R14
 0000006C          ENDP ; 'putchar?T'


*** CODE SEGMENT '?PR?getchar?T?VCOMuser':
  471: int getchar ( BYTE portNum )  {                    /* Read character from Serial Port   */
 00000000  1C01      MOV         R1,R0 ; portNum
 00000002  ---- Variable 'portNum' assigned to Register 'R1' ----
  473:   if ( portNum == 0 ) {
 00000002  1C08      MOV         R0,R1 ; portNum
 00000004  0600      LSL         R0,R0,#0x18 ; portNum
 00000006  0E00      LSR         R0,R0,#0x18
 00000008  2800      CMP         R0,#0x0
 0000000A  D107      BNE         L_62  ; T=0x0000001C
  474:     while (!(U0LSR & 0x01));
 0000000C          L_53:
 0000000C  4800      LDR         R0,=0xE000C014
 0000000E  7800      LDRB        R0,[R0,#0x0]
 00000010  2101      MOV         R1,#0x1
 00000012  4208      TST         R0,R1
 00000014  D0FA      BEQ         L_53  ; T=0x0000000C
  475:       return (U0RBR);
 00000016  4800      LDR         R0,=0xE000C000
 00000018  7800      LDRB        R0,[R0,#0x0]
 0000001A  E006      B           L_57  ; T=0x0000002A
  478:     while (!(U1LSR & 0x01));
 0000001C          L_62:
 0000001C          L_59:
 0000001C  4800      LDR         R0,=0xE0010014
 0000001E  7800      LDRB        R0,[R0,#0x0]
 00000020  2101      MOV         R1,#0x1
 00000022  4208      TST         R0,R1
 00000024  D0FA      BEQ         L_59  ; T=0x0000001C
  479:       return (U1RBR);
 00000026  4800      LDR         R0,=0xE0010000
 00000028  7800      LDRB        R0,[R0,#0x0]
  481: }
 0000002A          L_57:
 0000002A  4770      BX          R14
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 24  

 0000002C          ENDP ; 'getchar?T'


*** CODE SEGMENT '?PR?SetSIOBaudrate?T?VCOMuser':
  484: void SetSIOBaudrate( BYTE channelNum, BYTE Data )
 00000000  B410      PUSH        {R4}
 00000002  ---- Variable 'Data' assigned to Register 'R1' ----
 00000002  1C02      MOV         R2,R0 ; channelNum
 00000004  ---- Variable 'channelNum' assigned to Register 'R2' ----
  493:   if ( channelNum == 0 ) {
 00000004  1C10      MOV         R0,R2 ; channelNum
 00000006  0600      LSL         R0,R0,#0x18 ; channelNum
 00000008  0E00      LSR         R0,R0,#0x18
 0000000A  2800      CMP         R0,#0x0
 0000000C  D148      BNE         L_63  ; T=0x000000A0
  494:     U0FCR = 0x07;                  /* Enable and reset TX and RX FIFO. */
 0000000E  2307      MOV         R3,#0x7
 00000010  4800      LDR         R0,=0xE000C008
 00000012  7003      STRB        R3,[R0,#0x0]
  495:     U0LCR |= 0x80;  
 00000014  2480      MOV         R4,#0x80
 00000016  4800      LDR         R0,=0xE000C00C
 00000018  7803      LDRB        R3,[R0,#0x0]
 0000001A  4323      ORR         R3,R4
 0000001C  7003      STRB        R3,[R0,#0x0]
  496:     if ( Data == 0x01 ) {
 0000001E  1C08      MOV         R0,R1 ; Data
 00000020  0600      LSL         R0,R0,#0x18 ; Data
 00000022  0E00      LSR         R0,R0,#0x18
 00000024  2801      CMP         R0,#0x1
 00000026  D106      BNE         L_64  ; T=0x00000036
  497:         U0DLL = 0x20;
 00000028  2320      MOV         R3,#0x20
 0000002A  4800      LDR         R0,=0xE000C000
 0000002C  7003      STRB        R3,[R0,#0x0]
  498:         U0DLM = 0x00;
 0000002E  2300      MOV         R3,#0x0
 00000030  4800      LDR         R0,=0xE000C004
 00000032  7003      STRB        R3,[R0,#0x0]
  499:     }
 00000034  E02E      B           L_65  ; T=0x00000094
 00000036          L_64:
  500:     else if ( Data == 0x02 ) {
 00000036  1C08      MOV         R0,R1 ; Data
 00000038  0600      LSL         R0,R0,#0x18 ; Data
 0000003A  0E00      LSR         R0,R0,#0x18
 0000003C  2802      CMP         R0,#0x2
 0000003E  D106      BNE         L_66  ; T=0x0000004E
  501:         U0DLL = 0x41;
 00000040  2341      MOV         R3,#0x41
 00000042  4800      LDR         R0,=0xE000C000
 00000044  7003      STRB        R3,[R0,#0x0]
  502:         U0DLM = 0x00;
 00000046  2300      MOV         R3,#0x0
 00000048  4800      LDR         R0,=0xE000C004
 0000004A  7003      STRB        R3,[R0,#0x0]
  503:     }
 0000004C  E022      B           L_65  ; T=0x00000094
 0000004E          L_66:
  504:     else if ( Data == 0x03 ) {
 0000004E  1C08      MOV         R0,R1 ; Data
 00000050  0600      LSL         R0,R0,#0x18 ; Data
 00000052  0E00      LSR         R0,R0,#0x18
 00000054  2803      CMP         R0,#0x3
 00000056  D106      BNE         L_68  ; T=0x00000066
  505:         U0DLL = 0x61;
 00000058  2361      MOV         R3,#0x61
 0000005A  4800      LDR         R0,=0xE000C000
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 25  

 0000005C  7003      STRB        R3,[R0,#0x0]
  506:         U0DLM = 0x00;
 0000005E  2300      MOV         R3,#0x0
 00000060  4800      LDR         R0,=0xE000C004
 00000062  7003      STRB        R3,[R0,#0x0]
  507:     }
 00000064  E016      B           L_65  ; T=0x00000094
 00000066          L_68:
  508:     else if ( Data == 0x06 ) {
 00000066  1C08      MOV         R0,R1 ; Data
 00000068  0600      LSL         R0,R0,#0x18 ; Data
 0000006A  0E00      LSR         R0,R0,#0x18
 0000006C  2806      CMP         R0,#0x6
 0000006E  D106      BNE         L_70  ; T=0x0000007E
  509:         U0DLL = 0xC3;
 00000070  23C3      MOV         R3,#0xC3
 00000072  4800      LDR         R0,=0xE000C000
 00000074  7003      STRB        R3,[R0,#0x0]
  510:         U0DLM = 0x00;
 00000076  2300      MOV         R3,#0x0
 00000078  4800      LDR         R0,=0xE000C004
 0000007A  7003      STRB        R3,[R0,#0x0]
  511:     }
 0000007C  E00A      B           L_65  ; T=0x00000094
 0000007E          L_70:
  512:     else if ( Data == 0x0C ) {
 0000007E  1C08      MOV         R0,R1 ; Data
 00000080  0600      LSL         R0,R0,#0x18 ; Data
 00000082  0E00      LSR         R0,R0,#0x18
 00000084  280C      CMP         R0,#0xC
 00000086  D105      BNE         L_65  ; T=0x00000094
  513:         U0DLL = 0x86;
 00000088  2386      MOV         R3,#0x86
 0000008A  4800      LDR         R0,=0xE000C000
 0000008C  7003      STRB        R3,[R0,#0x0]
  514:         U0DLM = 0x01;
 0000008E  2301      MOV         R3,#0x1
 00000090  4800      LDR         R0,=0xE000C004
 00000092  7003      STRB        R3,[R0,#0x0]
  515:     }     
 00000094          L_65:
  516:     U0LCR &= ~0x80;
 00000094  247F      MOV         R4,#0x7F
 00000096  4800      LDR         R0,=0xE000C00C
 00000098  7803      LDRB        R3,[R0,#0x0]
 0000009A  4023      AND         R3,R4
 0000009C  7003      STRB        R3,[R0,#0x0]
  517:   }
 0000009E  E04C      B           L_73  ; T=0x0000013A
 000000A0          L_63:
  518:   else if ( channelNum == 1 ) {
 000000A0  1C10      MOV         R0,R2 ; channelNum
 000000A2  0600      LSL         R0,R0,#0x18 ; channelNum
 000000A4  0E00      LSR         R0,R0,#0x18
 000000A6  2801      CMP         R0,#0x1
 000000A8  D147      BNE         L_73  ; T=0x0000013A
  519:     U1FCR = 0x07;                  /* Enable and reset TX and RX FIFO. */
 000000AA  2207      MOV         R2,#0x7
 000000AC  4800      LDR         R0,=0xE0010008
 000000AE  7002      STRB        R2,[R0,#0x0]
  520:     U1LCR |= 0x80;
 000000B0  2380      MOV         R3,#0x80
 000000B2  4800      LDR         R0,=0xE001000C
 000000B4  7802      LDRB        R2,[R0,#0x0]
 000000B6  431A      ORR         R2,R3
 000000B8  7002      STRB        R2,[R0,#0x0]
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 26  

  521:     if ( Data == 0x01 ) {
 000000BA  1C08      MOV         R0,R1 ; Data
 000000BC  0600      LSL         R0,R0,#0x18 ; Data
 000000BE  0E00      LSR         R0,R0,#0x18
 000000C0  2801      CMP         R0,#0x1
 000000C2  D106      BNE         L_75  ; T=0x000000D2
  522:         U1DLL = 0x20;
 000000C4  2220      MOV         R2,#0x20
 000000C6  4800      LDR         R0,=0xE0010000
 000000C8  7002      STRB        R2,[R0,#0x0]
  523:         U1DLM = 0x00;
 000000CA  2200      MOV         R2,#0x0
 000000CC  4800      LDR         R0,=0xE0010004
 000000CE  7002      STRB        R2,[R0,#0x0]
  524:     }
 000000D0  E02E      B           L_76  ; T=0x00000130
 000000D2          L_75:
  525:     else if ( Data == 0x02 ) {
 000000D2  1C08      MOV         R0,R1 ; Data
 000000D4  0600      LSL         R0,R0,#0x18 ; Data
 000000D6  0E00      LSR         R0,R0,#0x18
 000000D8  2802      CMP         R0,#0x2
 000000DA  D106      BNE         L_77  ; T=0x000000EA
  526:         U1DLL = 0x41;
 000000DC  2241      MOV         R2,#0x41
 000000DE  4800      LDR         R0,=0xE0010000
 000000E0  7002      STRB        R2,[R0,#0x0]
  527:         U1DLM = 0x00;
 000000E2  2200      MOV         R2,#0x0
 000000E4  4800      LDR         R0,=0xE0010004
 000000E6  7002      STRB        R2,[R0,#0x0]
  528:     }
 000000E8  E022      B           L_76  ; T=0x00000130
 000000EA          L_77:
  529:     else if ( Data == 0x03 ) {
 000000EA  1C08      MOV         R0,R1 ; Data
 000000EC  0600      LSL         R0,R0,#0x18 ; Data
 000000EE  0E00      LSR         R0,R0,#0x18
 000000F0  2803      CMP         R0,#0x3
 000000F2  D106      BNE         L_79  ; T=0x00000102
  530:         U1DLL = 0x61;
 000000F4  2261      MOV         R2,#0x61
 000000F6  4800      LDR         R0,=0xE0010000
 000000F8  7002      STRB        R2,[R0,#0x0]
  531:         U1DLM = 0x00;
 000000FA  2200      MOV         R2,#0x0
 000000FC  4800      LDR         R0,=0xE0010004
 000000FE  7002      STRB        R2,[R0,#0x0]
  532:     }
 00000100  E016      B           L_76  ; T=0x00000130
 00000102          L_79:
  533:     else if ( Data == 0x06 ) {
 00000102  1C08      MOV         R0,R1 ; Data
 00000104  0600      LSL         R0,R0,#0x18 ; Data
 00000106  0E00      LSR         R0,R0,#0x18
 00000108  2806      CMP         R0,#0x6
 0000010A  D106      BNE         L_81  ; T=0x0000011A
  534:         U1DLL = 0xC3;
 0000010C  22C3      MOV         R2,#0xC3
 0000010E  4800      LDR         R0,=0xE0010000
 00000110  7002      STRB        R2,[R0,#0x0]
  535:         U1DLM = 0x00;
 00000112  2200      MOV         R2,#0x0
 00000114  4800      LDR         R0,=0xE0010004
 00000116  7002      STRB        R2,[R0,#0x0]
  536:     }
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 27  

 00000118  E00A      B           L_76  ; T=0x00000130
 0000011A          L_81:
  537:     else if ( Data == 0x0C ) {
 0000011A  1C08      MOV         R0,R1 ; Data
 0000011C  0600      LSL         R0,R0,#0x18 ; Data
 0000011E  0E00      LSR         R0,R0,#0x18
 00000120  280C      CMP         R0,#0xC
 00000122  D105      BNE         L_76  ; T=0x00000130
  538:         U1DLL = 0x86;
 00000124  2186      MOV         R1,#0x86
 00000126  4800      LDR         R0,=0xE0010000
 00000128  7001      STRB        R1,[R0,#0x0]
  539:         U1DLM = 0x01;
 0000012A  2101      MOV         R1,#0x1
 0000012C  4800      LDR         R0,=0xE0010004
 0000012E  7001      STRB        R1,[R0,#0x0]
  540:     }
 00000130          L_76:
  541:     U1LCR &= ~0x80;
 00000130  227F      MOV         R2,#0x7F
 00000132  4800      LDR         R0,=0xE001000C
 00000134  7801      LDRB        R1,[R0,#0x0]
 00000136  4011      AND         R1,R2
 00000138  7001      STRB        R1,[R0,#0x0]
  542:   }
 0000013A          L_73:
  543: }
 0000013A  BC10      POP         {R4}
 0000013C  4770      BX          R14
 0000013E          ENDP ; 'SetSIOBaudrate?T'


*** CODE SEGMENT '?PR?SetSIOStopBit?T?VCOMuser':
  545: void SetSIOStopBit( BYTE channelNum, BYTE ConfigValue )
 00000000  B410      PUSH        {R4}
 00000002  ---- Variable 'ConfigValue' assigned to Register 'R1' ----
 00000002  1C03      MOV         R3,R0 ; channelNum
 00000004  ---- Variable 'channelNum' assigned to Register 'R3' ----
 00000004  ---- Variable 'lcr' assigned to Register 'R2' ----
  546: {
 00000004            ; SCOPE-START
  550:   if ( channelNum == 0 ) {
 00000004  1C18      MOV         R0,R3 ; channelNum
 00000006  0600      LSL         R0,R0,#0x18 ; channelNum
 00000008  0E00      LSR         R0,R0,#0x18
 0000000A  2800      CMP         R0,#0x0
 0000000C  D113      BNE         L_84  ; T=0x00000036
  551:     lcr = U0LCR & 0xFB;
 0000000E  4800      LDR         R0,=0xE000C00C
 00000010  7800      LDRB        R0,[R0,#0x0]
 00000012  1C02      MOV         R2,R0
 00000014  20FB      MOV         R0,#0xFB
 00000016  4002      AND         R2,R0
 00000018  0612      LSL         R2,R2,#0x18
 0000001A  0E12      LSR         R2,R2,#0x18
  552:     U0LCR = lcr | (ConfigValue << 2);           
 0000001C  1C08      MOV         R0,R1 ; ConfigValue
 0000001E  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000020  0E00      LSR         R0,R0,#0x18
 00000022  0080      LSL         R0,R0,#0x2
 00000024  1C14      MOV         R4,R2 ; lcr
 00000026  0624      LSL         R4,R4,#0x18 ; lcr
 00000028  0E24      LSR         R4,R4,#0x18
 0000002A  4304      ORR         R4,R0
 0000002C  0624      LSL         R4,R4,#0x18
 0000002E  0E24      LSR         R4,R4,#0x18
 00000030  4800      LDR         R0,=0xE000C00C
 00000032  7004      STRB        R4,[R0,#0x0]
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 28  

  553:   }
 00000034  E017      B           L_85  ; T=0x00000066
 00000036          L_84:
  554:   else if ( channelNum == 1 ) {
 00000036  1C18      MOV         R0,R3 ; channelNum
 00000038  0600      LSL         R0,R0,#0x18 ; channelNum
 0000003A  0E00      LSR         R0,R0,#0x18
 0000003C  2801      CMP         R0,#0x1
 0000003E  D112      BNE         L_85  ; T=0x00000066
  555:       lcr = U1LCR & 0xFB;
 00000040  4800      LDR         R0,=0xE001000C
 00000042  7800      LDRB        R0,[R0,#0x0]
 00000044  1C02      MOV         R2,R0
 00000046  20FB      MOV         R0,#0xFB
 00000048  4002      AND         R2,R0
 0000004A  0612      LSL         R2,R2,#0x18
 0000004C  0E12      LSR         R2,R2,#0x18
  556:     U1LCR = lcr | (ConfigValue << 2);
 0000004E  1C08      MOV         R0,R1 ; ConfigValue
 00000050  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000052  0E00      LSR         R0,R0,#0x18
 00000054  0080      LSL         R0,R0,#0x2
 00000056  1C11      MOV         R1,R2 ; lcr
 00000058  0609      LSL         R1,R1,#0x18 ; lcr
 0000005A  0E09      LSR         R1,R1,#0x18
 0000005C  4301      ORR         R1,R0
 0000005E  0609      LSL         R1,R1,#0x18
 00000060  0E09      LSR         R1,R1,#0x18
 00000062  4800      LDR         R0,=0xE001000C
 00000064  7001      STRB        R1,[R0,#0x0]
  557:   }
 00000066          L_85:
 00000066            ; SCOPE-END
  558: }
 00000066  BC10      POP         {R4}
 00000068  4770      BX          R14
 0000006A          ENDP ; 'SetSIOStopBit?T'


*** CODE SEGMENT '?PR?SetSIODataBit?T?VCOMuser':
  560: void SetSIODataBit( BYTE channelNum, BYTE ConfigValue )
 00000000  B410      PUSH        {R4}
 00000002  ---- Variable 'ConfigValue' assigned to Register 'R1' ----
 00000002  1C03      MOV         R3,R0 ; channelNum
 00000004  ---- Variable 'channelNum' assigned to Register 'R3' ----
 00000004  ---- Variable 'lcr' assigned to Register 'R2' ----
  561: {
 00000004            ; SCOPE-START
  564:   if ( channelNum == 0 ) {
 00000004  1C18      MOV         R0,R3 ; channelNum
 00000006  0600      LSL         R0,R0,#0x18 ; channelNum
 00000008  0E00      LSR         R0,R0,#0x18
 0000000A  2800      CMP         R0,#0x0
 0000000C  D112      BNE         L_87  ; T=0x00000034
  565:     lcr = U0LCR & 0xFC;
 0000000E  4800      LDR         R0,=0xE000C00C
 00000010  7800      LDRB        R0,[R0,#0x0]
 00000012  1C02      MOV         R2,R0
 00000014  20FC      MOV         R0,#0xFC
 00000016  4002      AND         R2,R0
 00000018  0612      LSL         R2,R2,#0x18
 0000001A  0E12      LSR         R2,R2,#0x18
  566:     U0LCR = lcr | ConfigValue;          
 0000001C  1C08      MOV         R0,R1 ; ConfigValue
 0000001E  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000020  0E00      LSR         R0,R0,#0x18
 00000022  1C14      MOV         R4,R2 ; lcr
 00000024  0624      LSL         R4,R4,#0x18 ; lcr
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 29  

 00000026  0E24      LSR         R4,R4,#0x18
 00000028  4304      ORR         R4,R0
 0000002A  0624      LSL         R4,R4,#0x18
 0000002C  0E24      LSR         R4,R4,#0x18
 0000002E  4800      LDR         R0,=0xE000C00C
 00000030  7004      STRB        R4,[R0,#0x0]
  567:   }
 00000032  E016      B           L_88  ; T=0x00000062
 00000034          L_87:
  568:   else if ( channelNum == 1 ) {
 00000034  1C18      MOV         R0,R3 ; channelNum
 00000036  0600      LSL         R0,R0,#0x18 ; channelNum
 00000038  0E00      LSR         R0,R0,#0x18
 0000003A  2801      CMP         R0,#0x1
 0000003C  D111      BNE         L_88  ; T=0x00000062
  569:       lcr = U1LCR & 0xFC;
 0000003E  4800      LDR         R0,=0xE001000C
 00000040  7800      LDRB        R0,[R0,#0x0]
 00000042  1C02      MOV         R2,R0
 00000044  20FC      MOV         R0,#0xFC
 00000046  4002      AND         R2,R0
 00000048  0612      LSL         R2,R2,#0x18
 0000004A  0E12      LSR         R2,R2,#0x18
  570:     U1LCR = lcr | ConfigValue;
 0000004C  1C08      MOV         R0,R1 ; ConfigValue
 0000004E  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000050  0E00      LSR         R0,R0,#0x18
 00000052  1C11      MOV         R1,R2 ; lcr
 00000054  0609      LSL         R1,R1,#0x18 ; lcr
 00000056  0E09      LSR         R1,R1,#0x18
 00000058  4301      ORR         R1,R0
 0000005A  0609      LSL         R1,R1,#0x18
 0000005C  0E09      LSR         R1,R1,#0x18
 0000005E  4800      LDR         R0,=0xE001000C
 00000060  7001      STRB        R1,[R0,#0x0]
  571:   }
 00000062          L_88:
 00000062            ; SCOPE-END
  572: }
 00000062  BC10      POP         {R4}
 00000064  4770      BX          R14
 00000066          ENDP ; 'SetSIODataBit?T'


*** CODE SEGMENT '?PR?SetSIOParity?T?VCOMuser':
  574: void SetSIOParity( BYTE channelNum, BYTE ConfigValue )
 00000000  B410      PUSH        {R4}
 00000002  ---- Variable 'ConfigValue' assigned to Register 'R1' ----
 00000002  1C03      MOV         R3,R0 ; channelNum
 00000004  ---- Variable 'channelNum' assigned to Register 'R3' ----
 00000004  ---- Variable 'lcr' assigned to Register 'R2' ----
  575: {
 00000004            ; SCOPE-START
  578:   if ( channelNum == 0 ) {
 00000004  1C18      MOV         R0,R3 ; channelNum
 00000006  0600      LSL         R0,R0,#0x18 ; channelNum
 00000008  0E00      LSR         R0,R0,#0x18
 0000000A  2800      CMP         R0,#0x0
 0000000C  D113      BNE         L_90  ; T=0x00000036
  579:         lcr = U0LCR & 0xCF;
 0000000E  4800      LDR         R0,=0xE000C00C
 00000010  7800      LDRB        R0,[R0,#0x0]
 00000012  1C02      MOV         R2,R0
 00000014  20CF      MOV         R0,#0xCF
 00000016  4002      AND         R2,R0
 00000018  0612      LSL         R2,R2,#0x18
 0000001A  0E12      LSR         R2,R2,#0x18
  580:         U0LCR = lcr | (ConfigValue << 4);
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 30  

 0000001C  1C08      MOV         R0,R1 ; ConfigValue
 0000001E  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000020  0E00      LSR         R0,R0,#0x18
 00000022  0100      LSL         R0,R0,#0x4
 00000024  1C14      MOV         R4,R2 ; lcr
 00000026  0624      LSL         R4,R4,#0x18 ; lcr
 00000028  0E24      LSR         R4,R4,#0x18
 0000002A  4304      ORR         R4,R0
 0000002C  0624      LSL         R4,R4,#0x18
 0000002E  0E24      LSR         R4,R4,#0x18
 00000030  4800      LDR         R0,=0xE000C00C
 00000032  7004      STRB        R4,[R0,#0x0]
  581:   }
 00000034  E017      B           L_91  ; T=0x00000066
 00000036          L_90:
  582:   else if ( channelNum == 1 ) {
 00000036  1C18      MOV         R0,R3 ; channelNum
 00000038  0600      LSL         R0,R0,#0x18 ; channelNum
 0000003A  0E00      LSR         R0,R0,#0x18
 0000003C  2801      CMP         R0,#0x1
 0000003E  D112      BNE         L_91  ; T=0x00000066
  583:           lcr = U1LCR & 0xCF;
 00000040  4800      LDR         R0,=0xE001000C
 00000042  7800      LDRB        R0,[R0,#0x0]
 00000044  1C02      MOV         R2,R0
 00000046  20CF      MOV         R0,#0xCF
 00000048  4002      AND         R2,R0
 0000004A  0612      LSL         R2,R2,#0x18
 0000004C  0E12      LSR         R2,R2,#0x18
  584:         U1LCR = lcr | (ConfigValue << 4);
 0000004E  1C08      MOV         R0,R1 ; ConfigValue
 00000050  0600      LSL         R0,R0,#0x18 ; ConfigValue
 00000052  0E00      LSR         R0,R0,#0x18
 00000054  0100      LSL         R0,R0,#0x4
 00000056  1C11      MOV         R1,R2 ; lcr
 00000058  0609      LSL         R1,R1,#0x18 ; lcr
 0000005A  0E09      LSR         R1,R1,#0x18
 0000005C  4301      ORR         R1,R0
 0000005E  0609      LSL         R1,R1,#0x18
 00000060  0E09      LSR         R1,R1,#0x18
 00000062  4800      LDR         R0,=0xE001000C
 00000064  7001      STRB        R1,[R0,#0x0]
  585:   }
 00000066          L_91:
 00000066            ; SCOPE-END
  586: }
 00000066  BC10      POP         {R4}
 00000068  4770      BX          R14
 0000006A          ENDP ; 'SetSIOParity?T'


*** CODE SEGMENT '?PR?SetSIOFlowControl?T?VCOMuser':
  597: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'SetSIOFlowControl?T'


*** CODE SEGMENT '?PR?SetSIODTR?T?VCOMuser':
  599: void SetSIODTR( BYTE channelNum, BYTE ConfigValue )
 00000000  ---- Variable 'ConfigValue' assigned to Register 'R1' ----
 00000000  1C02      MOV         R2,R0 ; channelNum
 00000002  ---- Variable 'channelNum' assigned to Register 'R2' ----
  600: {
 00000002            ; SCOPE-START
  603:   if ( channelNum == 1 ) {
 00000002  1C10      MOV         R0,R2 ; channelNum
 00000004  0600      LSL         R0,R0,#0x18 ; channelNum
 00000006  0E00      LSR         R0,R0,#0x18
 00000008  2801      CMP         R0,#0x1
 0000000A  D111      BNE         L_96  ; T=0x00000030
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 31  

  604:       mcr = U1MCR & 0xFE;
 0000000C  4800      LDR         R0,=0xE0010010
 0000000E  7800      LDRB        R0,[R0,#0x0]
 00000010  1C02      MOV         R2,R0
 00000012  20FE      MOV         R0,#0xFE
 00000014  4002      AND         R2,R0
 00000016  0612      LSL         R2,R2,#0x18
 00000018  0E12      LSR         R2,R2,#0x18
 0000001A  ---- Variable 'mcr' assigned to Register 'R2' ----
  605:     U1MCR = mcr | ConfigValue;
 0000001A  1C08      MOV         R0,R1 ; ConfigValue
 0000001C  0600      LSL         R0,R0,#0x18 ; ConfigValue
 0000001E  0E00      LSR         R0,R0,#0x18
 00000020  1C11      MOV         R1,R2 ; mcr
 00000022  0609      LSL         R1,R1,#0x18 ; mcr
 00000024  0E09      LSR         R1,R1,#0x18
 00000026  4301      ORR         R1,R0
 00000028  0609      LSL         R1,R1,#0x18
 0000002A  0E09      LSR         R1,R1,#0x18
 0000002C  4800      LDR         R0,=0xE0010010
 0000002E  7001      STRB        R1,[R0,#0x0]
  606:   }
 00000030          L_96:
 00000030            ; SCOPE-END
  607: }
 00000030  4770      BX          R14
 00000032          ENDP ; 'SetSIODTR?T'


*** CODE SEGMENT '?PR?SetSIORTS?T?VCOMuser':
  609: void SetSIORTS( BYTE channelNum, BYTE ConfigValue )
 00000000  ---- Variable 'ConfigValue' assigned to Register 'R1' ----
 00000000  1C02      MOV         R2,R0 ; channelNum
 00000002  ---- Variable 'channelNum' assigned to Register 'R2' ----
  610: {
 00000002            ; SCOPE-START
  614:   if ( channelNum == 1 ) {
 00000002  1C10      MOV         R0,R2 ; channelNum
 00000004  0600      LSL         R0,R0,#0x18 ; channelNum
 00000006  0E00      LSR         R0,R0,#0x18
 00000008  2801      CMP         R0,#0x1
 0000000A  D112      BNE         L_97  ; T=0x00000032
  615:       mcr = U1MCR & 0xFD;
 0000000C  4800      LDR         R0,=0xE0010010
 0000000E  7800      LDRB        R0,[R0,#0x0]
 00000010  1C02      MOV         R2,R0
 00000012  20FD      MOV         R0,#0xFD
 00000014  4002      AND         R2,R0
 00000016  0612      LSL         R2,R2,#0x18
 00000018  0E12      LSR         R2,R2,#0x18
 0000001A  ---- Variable 'mcr' assigned to Register 'R2' ----
  616:     U1MCR = mcr | (ConfigValue << 1);
 0000001A  1C08      MOV         R0,R1 ; ConfigValue
 0000001C  0600      LSL         R0,R0,#0x18 ; ConfigValue
 0000001E  0E00      LSR         R0,R0,#0x18
 00000020  0040      LSL         R0,R0,#0x1
 00000022  1C11      MOV         R1,R2 ; mcr
 00000024  0609      LSL         R1,R1,#0x18 ; mcr
 00000026  0E09      LSR         R1,R1,#0x18
 00000028  4301      ORR         R1,R0
 0000002A  0609      LSL         R1,R1,#0x18
 0000002C  0E09      LSR         R1,R1,#0x18
 0000002E  4800      LDR         R0,=0xE0010010
 00000030  7001      STRB        R1,[R0,#0x0]
  617:   }
 00000032          L_97:
 00000032            ; SCOPE-END
  618: }
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 32  

 00000032  4770      BX          R14
 00000034          ENDP ; 'SetSIORTS?T'


*** CODE SEGMENT '?PR?GetSIOModemStatus?T?VCOMuser':
  623: }
 00000000  4770      BX          R14
 00000002          ENDP ; 'GetSIOModemStatus?T'


*** CODE SEGMENT '?PR?VCOM_GetSIOSetup?T?VCOMuser':
  633:   return (TRUE);  
 00000000  2001      MOV         R0,#0x1
  634: }
 00000002  4770      BX          R14
 00000004          ENDP ; 'VCOM_GetSIOSetup?T'


*** CODE SEGMENT '?PR?VCOM_SetSIOSetup?T?VCOMuser':
  643: BOOL VCOM_SetSIOSetup( BYTE Cmd, BYTE Data ) {
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C0D      MOV         R5,R1 ; Data
 00000004  ---- Variable 'Data' assigned to Register 'R5' ----
 00000004  1C01      MOV         R1,R0 ; Cmd
 00000006  ---- Variable 'Cmd' assigned to Register 'R1' ----
 00000006  ---- Variable 'ChannelNum' assigned to Register 'R4' ----
 00000006            ; SCOPE-START
  649:   if ( !(Cmd & 0x20) )
 00000006  1C08      MOV         R0,R1 ; Cmd
 00000008  0600      LSL         R0,R0,#0x18 ; Cmd
 0000000A  0E00      LSR         R0,R0,#0x18
 0000000C  2220      MOV         R2,#0x20
 0000000E  4210      TST         R0,R2
 00000010  D101      BNE         L_99  ; T=0x00000016
  650:     ChannelNum = 0;
 00000012  2400      MOV         R4,#0x0
 00000014  E000      B           L_100  ; T=0x00000018
 00000016          L_99:
  652:     ChannelNum = 1;
 00000016  2401      MOV         R4,#0x1
 00000018          L_100:
  654:   Cmd &= ~0x20;         /* clear bit 5, use all cmd for channel 0 */
 00000018  20DF      MOV         R0,#0xDF
 0000001A  4001      AND         R1,R0
  655:   switch ( Cmd ) {
 0000001C  1C08      MOV         R0,R1 ; Cmd
 0000001E  2804      CMP         R0,#0x4 ; Cmd
 00000020  D018      BEQ         L_104  ; T=0x00000054
 00000022  2805      CMP         R0,#0x5 ; Cmd
 00000024  D01F      BEQ         L_105  ; T=0x00000066
 00000026  2806      CMP         R0,#0x6 ; Cmd
 00000028  D026      BEQ         L_106  ; T=0x00000078
 0000002A  2807      CMP         R0,#0x7 ; Cmd
 0000002C  D02D      BEQ         L_107  ; T=0x0000008A
 0000002E  2808      CMP         R0,#0x8 ; Cmd
 00000030  D034      BEQ         L_108  ; T=0x0000009C
 00000032  2809      CMP         R0,#0x9 ; Cmd
 00000034  D03B      BEQ         L_109  ; T=0x000000AE
 00000036  280B      CMP         R0,#0xB ; Cmd
 00000038  D04A      BEQ         L_101  ; T=0x000000D0
 0000003A  280C      CMP         R0,#0xC ; Cmd
 0000003C  D040      BEQ         L_111  ; T=0x000000C0
 0000003E  2803      CMP         R0,#0x3 ; Cmd
 00000040  D144      BNE         L_103  ; T=0x000000CC
  656:     case BAUDRATE_SETUP:
 00000042          L_102:
  657:       SetSIOBaudrate( ChannelNum, Data );
 00000042  1C20      MOV         R0,R4 ; ChannelNum
 00000044  0600      LSL         R0,R0,#0x18 ; ChannelNum
 00000046  0E00      LSR         R0,R0,#0x18
 00000048  1C29      MOV         R1,R5 ; Data
 0000004A  0609      LSL         R1,R1,#0x18 ; Data
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 33  

 0000004C  0E09      LSR         R1,R1,#0x18
 0000004E  F7FF      BL          SetSIOBaudrate?T  ; T=0x0001  (1)
 00000050  FFD7      BL          SetSIOBaudrate?T  ; T=0x0001  (2)
  658:       break;
 00000052  E03D      B           L_101  ; T=0x000000D0
  659:     case STOPBIT_SETUP:
 00000054          L_104:
  660:         SetSIOStopBit( ChannelNum, Data );
 00000054  1C20      MOV         R0,R4 ; ChannelNum
 00000056  0600      LSL         R0,R0,#0x18 ; ChannelNum
 00000058  0E00      LSR         R0,R0,#0x18
 0000005A  1C29      MOV         R1,R5 ; Data
 0000005C  0609      LSL         R1,R1,#0x18 ; Data
 0000005E  0E09      LSR         R1,R1,#0x18
 00000060  F7FF      BL          SetSIOStopBit?T  ; T=0x0001  (1)
 00000062  FFCE      BL          SetSIOStopBit?T  ; T=0x0001  (2)
  661:       break;          
 00000064  E034      B           L_101  ; T=0x000000D0
  662:     case DATABIT_SETUP:
 00000066          L_105:
  663:         SetSIODataBit( ChannelNum, Data );
 00000066  1C20      MOV         R0,R4 ; ChannelNum
 00000068  0600      LSL         R0,R0,#0x18 ; ChannelNum
 0000006A  0E00      LSR         R0,R0,#0x18
 0000006C  1C29      MOV         R1,R5 ; Data
 0000006E  0609      LSL         R1,R1,#0x18 ; Data
 00000070  0E09      LSR         R1,R1,#0x18
 00000072  F7FF      BL          SetSIODataBit?T  ; T=0x0001  (1)
 00000074  FFC5      BL          SetSIODataBit?T  ; T=0x0001  (2)
  664:       break;
 00000076  E02B      B           L_101  ; T=0x000000D0
  665:     case PARITY_SETUP:
 00000078          L_106:
  666:         SetSIOParity( ChannelNum, Data );
 00000078  1C20      MOV         R0,R4 ; ChannelNum
 0000007A  0600      LSL         R0,R0,#0x18 ; ChannelNum
 0000007C  0E00      LSR         R0,R0,#0x18
 0000007E  1C29      MOV         R1,R5 ; Data
 00000080  0609      LSL         R1,R1,#0x18 ; Data
 00000082  0E09      LSR         R1,R1,#0x18
 00000084  F7FF      BL          SetSIOParity?T  ; T=0x0001  (1)
 00000086  FFBC      BL          SetSIOParity?T  ; T=0x0001  (2)
  667:       break;
 00000088  E022      B           L_101  ; T=0x000000D0
  668:     case FLOWCTRL_SETUP:
 0000008A          L_107:
  669:         SetSIOFlowControl( ChannelNum, Data );
 0000008A  1C20      MOV         R0,R4 ; ChannelNum
 0000008C  0600      LSL         R0,R0,#0x18 ; ChannelNum
 0000008E  0E00      LSR         R0,R0,#0x18
 00000090  1C29      MOV         R1,R5 ; Data
 00000092  0609      LSL         R1,R1,#0x18 ; Data
 00000094  0E09      LSR         R1,R1,#0x18
 00000096  F7FF      BL          SetSIOFlowControl?T  ; T=0x0001  (1)
 00000098  FFB3      BL          SetSIOFlowControl?T  ; T=0x0001  (2)
  670:       break;
 0000009A  E019      B           L_101  ; T=0x000000D0
  671:     case DTR_SETUP:
 0000009C          L_108:
  672:         SetSIODTR( ChannelNum, Data );
 0000009C  1C20      MOV         R0,R4 ; ChannelNum
 0000009E  0600      LSL         R0,R0,#0x18 ; ChannelNum
 000000A0  0E00      LSR         R0,R0,#0x18
 000000A2  1C29      MOV         R1,R5 ; Data
 000000A4  0609      LSL         R1,R1,#0x18 ; Data
 000000A6  0E09      LSR         R1,R1,#0x18
ARM COMPILER V2.53,  VCOMuser                                                              28/09/11  15:10:05  PAGE 34  

 000000A8  F7FF      BL          SetSIODTR?T  ; T=0x0001  (1)
 000000AA  FFAA      BL          SetSIODTR?T  ; T=0x0001  (2)
  673:       break;
 000000AC  E010      B           L_101  ; T=0x000000D0
  674:     case RTS_SETUP:
 000000AE          L_109:
  675:         SetSIORTS( ChannelNum, Data );
 000000AE  1C20      MOV         R0,R4 ; ChannelNum
 000000B0  0600      LSL         R0,R0,#0x18 ; ChannelNum
 000000B2  0E00      LSR         R0,R0,#0x18
 000000B4  1C29      MOV         R1,R5 ; Data
 000000B6  0609      LSL         R1,R1,#0x18 ; Data
 000000B8  0E09      LSR         R1,R1,#0x18
 000000BA  F7FF      BL          SetSIORTS?T  ; T=0x0001  (1)
 000000BC  FFA1      BL          SetSIORTS?T  ; T=0x0001  (2)
  676:       break;
 000000BE  E007      B           L_101  ; T=0x000000D0
  679:     case MODEM_SETUP:
 000000C0          L_111:
  680:         GetSIOModemStatus( ChannelNum );
 000000C0  1C20      MOV         R0,R4 ; ChannelNum
 000000C2  0600      LSL         R0,R0,#0x18 ; ChannelNum
 000000C4  0E00      LSR         R0,R0,#0x18
 000000C6  F7FF      BL          GetSIOModemStatus?T  ; T=0x0001  (1)
 000000C8  FF9B      BL          GetSIOModemStatus?T  ; T=0x0001  (2)
  681:       break;
 000000CA  E001      B           L_101  ; T=0x000000D0
  682:     default:
 000000CC          L_103:
  685:       return (FALSE);
 000000CC  2000      MOV         R0,#0x0
 000000CE  E000      B           L_112  ; T=0x000000D2
  686:   }
 000000D0          L_101:
  687:   return (TRUE);
 000000D0  2001      MOV         R0,#0x1
 000000D2            ; SCOPE-END
  688: }
 000000D2          L_112:
 000000D2  BC30      POP         {R4-R5}
 000000D4  BC08      POP         {R3}
 000000D6  4718      BX          R3
 000000D8          ENDP ; 'VCOM_SetSIOSetup?T'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =       327
  const size           =        62
End of Module Information.


ARM COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
